#include <ros/ros.h>
#include "sensor_msgs/LaserScan.h"
#include <tf/transform_datatypes.h>
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/PoseStamped.h" 
#include <nav_msgs/Path.h>
#include <tf/transform_listener.h>
#include <tf/tf.h>
#include <math.h>

#define GOAL_TOPIC "move_base_simple/goal"
#define PUBLISHER_TOPIC "cmd_vel0"
#define NODE_NAME "seek_behaviour"
#define PLAN_FRAME   "odom"
#define ROBOT_FRAME  "base_footprint"
#define SUBSCRIBER_BUFFER_SIZE 1	//!<Size of buffer for subscriber.

#define PUBLISHER_BUFFER_SIZE 1000	//!<Size of buffer for publisher.

#define ANGLE_COEF 2 //!<Coeficient for angles.

#define ROBOT_SPEED 0.10 //!<Speed of robot [m/s].

using namespace std;

enum State {
    IDLE,
    PREPROCESS,
    DRIVING,
    ARRIVED,
};

class SeekBehaviour {
public:
    // members

    // methods
    SeekBehaviour();
    geometry_msgs::PoseStamped getRobotPose();

    double calculateAngle(geometry_msgs::Pose current, geometry_msgs::Pose target);
    // Tunable parameters
    const static double FORWARD_SPEED_MPS = 0.5;
    const static double MIN_SCAN_ANGLE_RAD = -25.0 / 180 * M_PI;
    const static double MAX_SCAN_ANGLE_RAD = +25.0 / 180 * M_PI;
    const static float MIN_PROXIMITY_RANGE_M = 1; // Should be smaller than sensor_msgs::LaserScan::range_max
    void startMoving();



protected:
    // members
    ros::NodeHandle nh;
    ros::Subscriber goal_sub;
    ros::Publisher commandPub; // Publisher to the robot's velocity command topic
    ros::Subscriber laserSub; // Subscriber to the robot's laser scan topic
    geometry_msgs::PoseStamped goal;
    State currentState; // state of seeking procedure
    tf::TransformListener *listener;
    tf::StampedTransform transform;
    bool received;
    double angleCoef;
    double robotSpeed; //!<Speed of robot [m/s].
    double angleMinLeft; //!<Angle, at which was measured the shortest distance.
    double distMinLeft; //!<Minimum distance masured by sensor.
    double angleMinRight; //!<Angle, at which was measured the shortest distance.
    double distMinRight; //!<Minimum distance masured by sensor.


    void on_Goal_Received(geometry_msgs::PoseStamped msg);
    bool keepMoving; // Indicates whether the robot should continue moving
    void moveForward();
    void moveTurn(double FORWARD_SPEED_MPS);
    void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan);

};

SeekBehaviour::SeekBehaviour() {
    angleCoef=ANGLE_COEF;
    robotSpeed=ROBOT_SPEED;
    /* listener = new tf::TransformListener();
     currentState = IDLE;
     vel_pub = nh.advertise<geometry_msgs::Twist>(PUBLISHER_TOPIC, 1);*/
    goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(GOAL_TOPIC, 100, &SeekBehaviour::on_Goal_Received, this);
    received = false;

    keepMoving = true;
    // Advertise a new publisher for the simulated robot's velocity command topic
    commandPub = nh.advertise<geometry_msgs::Twist>("cmd_vel0", 10);
    // Subscribe to the simulated robot's laser scan topic
    laserSub = nh.subscribe("base_scan", 1, &SeekBehaviour::scanCallback, this);

}
// Send a velocity command

void SeekBehaviour::moveForward() {
   //preparing message
	geometry_msgs::Twist msg;
	
	msg.angular.z = direction*(P*r + S*sumR + D*diffR) + angleCoef * (angleMin - PI*direction/2);		//PI regulator
	
	if (distFront < wallDistance){
		msg.linear.x = 0;
	}
	else if (distFront < wallDistance * 2){
		msg.linear.x = 0.5*maxSpeed;
	}
	else if (fabs(angleMin)>1.75){
		msg.linear.x = 0.4*maxSpeed;
	}
	else {
		msg.linear.x = maxSpeed;
	}
	
	//sending information about message to console
	ROS_INFO("Sending msg: linear.x=%f, angular.z=%f",msg.linear.x,msg.angular.z);
	
    commandPub.publish(msg);
};

void SeekBehaviour::moveTurn(double fORWARD_SPEED_MPS) {
    geometry_msgs::Twist msg; // The default constructor will set all commands to 0
    msg.angular.z = fORWARD_SPEED_MPS;
    commandPub.publish(msg);
};
// Process the incoming laser scan message

void SeekBehaviour::scanCallback(const sensor_msgs::LaserScan::ConstPtr& msg) {
    // Find the closest range between the defined minimum and maximum angles
    //Calculation of array size from angle range and angle increment.
    //Calculation of array size from angle range and angle increment.
	//int size = (int) ((msg->angle_max - msg->angle_min)/msg->angle_increment);
	int size = msg->ranges.size();
	//ROS_INFO("array_length: [%d]", size); 
	
	//Variables whith index of highest and lowest value in array.
	int minIndex = size*(direction+1)/4;
	
	//This cycle goes through array and finds minimum
	for(int i=(size*(direction+1)/4); i<(size*(direction+3)/4); i++)
	{
		if (msg->ranges[i] < msg->ranges[minIndex] && msg->ranges[i] > 0.0){
			minIndex = i;
		}
	}
	
	//Calculation of angles from indexes and storing data to class variables.
	angleMin = (minIndex-size/2)*msg->angle_increment;
	distMin = msg->ranges[minIndex];
	distFront = msg->ranges[size/2];
	diffR = 2*(distMin - wallDistance) - r;
	r = distMin - wallDistance;
	sumR += r;
	
	//Sending info about processed data
	ROS_INFO("min: angle=%f, distance=%f, front=%f", angleMin, distMin, distFront);
	
    //Invoking method for publishing message
    moveForward();

}

void SeekBehaviour::startMoving() {
    ros::Rate rate(10);
    ROS_INFO("Start moving");
    // Keep spinning loop until user presses Ctrl+C or the robot got too close to an obstacle
    while (ros::ok() && keepMoving) {
        moveForward();
        ros::spinOnce(); // Need to call this function often to allow ROS to process incoming messages
        //rate.sleep();
    }
}

void SeekBehaviour::on_Goal_Received(geometry_msgs::PoseStamped goalMsg) {
    if (currentState == IDLE) {
        geometry_msgs::PoseStamped currentPose = getRobotPose();
        currentState = PREPROCESS;
        if (currentPose.pose.position.x != goalMsg.pose.position.x && currentPose.pose.position.y != goalMsg.pose.position.y) {

            goal = goalMsg;
            geometry_msgs::Twist twist;
            twist.angular.z = 0;
            twist.linear.x = 0;
            double turn = 0;
            tf::Quaternion qCur, qNext;

            qCur = tf::createQuaternionFromRPY(getRobotPose().pose.orientation.x, getRobotPose().pose.orientation.y, getRobotPose().pose.orientation.z);
            qNext = tf::createQuaternionFromYaw(calculateAngle(getRobotPose().pose, goalMsg.pose));
            double angle = qCur.angleShortestPath(qNext);

            //            twist.angular.z = -1.5;
            //            ROS_INFO_STREAM(angle);
            //            publish_cmd(twist);
        }
    }
}

double SeekBehaviour::calculateAngle(geometry_msgs::Pose current, geometry_msgs::Pose target) {

    double angleCalc = atan2((current.position.y - target.position.y), (current.position.x - target.position.x));
    //normalizing angle to <-pi; pi>
    if (fabs(angleCalc) > M_PI) {
        angleCalc = angleCalc - copysign(2 * M_PI, angleCalc);
    }
    return angleCalc;
}

geometry_msgs::PoseStamped SeekBehaviour::getRobotPose() {


    bool transform_exist = false;
    ros::Time now = ros::Time::now();
    geometry_msgs::PoseStamped current_robot_pose;
    transform_exist = listener->waitForTransform(PLAN_FRAME, ROBOT_FRAME, now, ros::Duration(2.0));
    if (transform_exist) {
        // ROS_INFO_STREAM("Transform found");
        listener->lookupTransform(PLAN_FRAME, ROBOT_FRAME, ros::Time(0), transform);

        current_robot_pose.header.frame_id = ROBOT_FRAME;
        current_robot_pose.pose.position.x = transform.getOrigin().x();
        current_robot_pose.pose.position.y = transform.getOrigin().y();
        current_robot_pose.pose.position.z = transform.getOrigin().z();
        current_robot_pose.pose.orientation.w = transform.getRotation().w();
        current_robot_pose.pose.orientation.x = transform.getRotation().x();
        current_robot_pose.pose.orientation.y = transform.getRotation().y();
        current_robot_pose.pose.orientation.z = transform.getRotation().z();

        // ROS_INFO_STREAM(current_robot_pose);
    }
    return current_robot_pose;
}

/*Main Function*/
int main(int argc, char **argv) {
    ros::init(argc, argv, NODE_NAME);
    SeekBehaviour seek_behaviour;
    seek_behaviour.startMoving();


    ros::spin();
    return 0;
}


