/*#include <ros/ros.h>
#include "sensor_msgs/LaserScan.h"
#include <tf/transform_datatypes.h>
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/PoseStamped.h" 
#include <nav_msgs/Path.h>
#include <tf/transform_listener.h>
#include <tf/tf.h>
#include <math.h>

#define GOAL_TOPIC "move_base_simple/goal"
#define PUBLISHER_TOPIC "cmd_vel0"
#define NODE_NAME "seek_behaviour"
#define PLAN_FRAME   "odom"
#define ROBOT_FRAME  "base_footprint"
#define SUBSCRIBER_BUFFER_SIZE 1	//!<Size of buffer for subscriber.

#define PUBLISHER_BUFFER_SIZE 1000	//!<Size of buffer for publisher.

#define ANGLE_COEF 2 //!<Coeficient for angles.

#define ROBOT_SPEED 0.10 //!<Speed of robot [m/s].

using namespace std;

enum State {
    IDLE,
    PREPROCESS,
    DRIVING,
    ARRIVED,
};

class SeekBehaviour {
public:
    // members

    // methods
    SeekBehaviour();

protected:
    // members
    ros::NodeHandle nh;
    ros::Subscriber goal_sub;
    ros::Publisher commandPub; // Publisher to the robot's velocity command topic
    ros::Subscriber laserSub; // Subscriber to the robot's laser scan topic
    geometry_msgs::PoseStamped currentPose,goal;
    double angleToGoal;
    
    State currentState; // state of seeking procedure
    tf::TransformListener *listener;
    tf::StampedTransform transform;
    bool received;
    	ros::Timer timer_;
        ros::Timer timer_1;
        int rate_;
        double robotAngle;
        bool running, rotate;


    void on_Goal_Received(geometry_msgs::PoseStamped msg);
    void scanCallback(const sensor_msgs::LaserScan::ConstPtr& scan);
    geometry_msgs::PoseStamped getRobotPose();
    double calculateAngle(geometry_msgs::Pose current, geometry_msgs::Pose target);
    void rotationProcessing(bool cw, int angle);
    bool stopToProcess();
    void rotateRobot();
     void DriveToGoal();
  void shooting();
  void pointing( double angle);
  void CalculateDistanceError(double X, double Y);
  void CalculateAngleErrorInRadians(double Y, double X);



  char nodeName []= "pointshoot_node";
  volatile double currentX =0.0;
  volatile double currentY =0.0;
  double goalX =0.0;
  double goalY =0.0;
  double angle_in_radians= 0.0;
  double distance = 0.0;
  double angle_Orientation =0.0;
  double goalOrientation =0.0;
  bool arrived = false;

};

SeekBehaviour::SeekBehaviour() {

    listener = new tf::TransformListener();
    received =rotate =running = false;
    int rate_ =50;
    commandPub = nh.advertise<geometry_msgs::Twist>(PUBLISHER_TOPIC, 10);
    goal_sub = nh.subscribe<geometry_msgs::PoseStamped>(GOAL_TOPIC, 100, &SeekBehaviour::on_Goal_Received, this);
    laserSub = nh.subscribe("base_scan", 1, &SeekBehaviour::scanCallback, this);
   //timer_ = nh.createTimer(ros::Duration(1.0/rate_), boost::bind(&SeekBehaviour::rotateRobot, this));
    // timer_1 = nh.createTimer(ros::Duration(1.0/rate_), boost::bind(&SeekBehaviour::stopToProcess, this));
    

}



// Process the incoming laser scan message
void SeekBehaviour::scanCallback(const sensor_msgs::LaserScan::ConstPtr& msg) {
    

}
  void SeekBehaviour::CalculateDistanceError(double X, double Y)
  {
    distance = ((int)(10.0*sqrt((pow(X, 2) )+ (pow (Y, 2) )))/10.0F);

  }

  void SeekBehaviour::CalculateAngleErrorInRadians(double Y,double X)
  {
    angle_in_radians = (int)(10.0*(atan2(Y, X)))/10.0F;
  }
//Process the incoming goals
void SeekBehaviour::on_Goal_Received(geometry_msgs::PoseStamped goalMsg) {
    //rotationProcessing(true, 90);
   arrived = false;
   goalX =goalMsg.pose.position.x;
   goalY =goalMsg.pose.position.y;
   

   double X =goalMsg.pose.position.x- currentX;
   double Y =goalMsg.pose.position.y- currentY;
   goalOrientation =  tf::getYaw(goalMsg.pose.orientation);
   CalculateDistanceError(X, Y);
   CalculateAngleErrorInRadians(Y,X);

   DriveToGoal ();
    
}

//Calculate angel between 2 lines
double SeekBehaviour::calculateAngle(geometry_msgs::Pose current, geometry_msgs::Pose target) {

    double angleCalc = atan2((current.position.y - target.position.y), (current.position.x - target.position.x));
    //normalizing angle to <-pi; pi>
    if (fabs(angleCalc) > M_PI) {
        angleCalc = angleCalc - copysign(2 * M_PI, angleCalc);
    }
        ROS_INFO_STREAM(angleCalc);
    return angleCalc;
}

//Get the current robot's Pose
geometry_msgs::PoseStamped SeekBehaviour::getRobotPose() {


    bool transform_exist = false;
    ros::Time now = ros::Time::now();
    geometry_msgs::PoseStamped current_robot_pose;
    transform_exist = listener->waitForTransform(PLAN_FRAME, ROBOT_FRAME, now, ros::Duration(2.0));
    if (transform_exist) {
        // ROS_INFO_STREAM("Transform found");
        listener->lookupTransform(PLAN_FRAME, ROBOT_FRAME, ros::Time(0), transform);

        current_robot_pose.header.frame_id = ROBOT_FRAME;
        current_robot_pose.pose.position.x = transform.getOrigin().x();
        current_robot_pose.pose.position.y = transform.getOrigin().y();
        current_robot_pose.pose.position.z = transform.getOrigin().z();
      double w=  current_robot_pose.pose.orientation.w = transform.getRotation().w();
      double x =  current_robot_pose.pose.orientation.x = transform.getRotation().x();
     double y =current_robot_pose.pose.orientation.y = transform.getRotation().y();
     double z =current_robot_pose.pose.orientation.z = transform.getRotation().z();    
     robotAngle=atan2(2*(y*x+w*z),w*w+x*x-y*y-z*z);
    }
    ROS_INFO_STREAM(current_robot_pose);
    return current_robot_pose;
}
/*Main Function*/
//int main(int argc, char **argv) {
//    ros::init(argc, argv, NODE_NAME);
//    SeekBehaviour seek_behaviour;
//   
//    ros::spin();
//    return 0;
//}
/*void SeekBehaviour::rotationProcessing(bool cw, int angle) {
    ROS_INFO_STREAM("bdsjbakdbckb ");
    double angular_speed = 5 * M_PI / 180; // Converting to radians
    double angleInRadius = angle * M_PI / 180;
    geometry_msgs::Twist theMsg;
    //We are now perfoming the rotation task:
    //Step1 we set all the linear values to 0 as we are not performing any linear motion
    theMsg.linear.x = 0;
    theMsg.linear.y = 0;
    theMsg.linear.z = 0;

    //Angular velocity in the Y-axies
    // We have to consider the rotation direction (clock/conter clockwise)
    //Clockwise == negative values
    //Conter clockwise = positive values
    theMsg.angular.y = 0;
    theMsg.angular.x = 0;
    if (cw == true)
        theMsg.angular.z = -abs(angular_speed);
    else
        theMsg.angular.z = abs(angular_speed);


    //Now Publishing the message
    commandPub.publish(theMsg);


    double current_angle = double(0);
    double T0 = ros::Time::now().toSec();
    ros::Rate rosRate(100);

    do {
        /* code */
//        commandPub.publish(theMsg);
//        double T1 = ros::Time::now().toSec();
//        current_angle = angular_speed * (T1 - T0);
//        ros::spinOnce();
//        rosRate.sleep();
//
//    } while (current_angle < angleInRadius); 
//    theMsg.angular.z = 0;
//    commandPub.publish(theMsg);
//}
//
//bool SeekBehaviour::stopToProcess() {
//    ROS_INFO_STREAM("Stop to Process ");
//    running = true;
//    geometry_msgs::Twist theMsg;
//   
//    theMsg.angular.z = 0;
//    theMsg.linear.x  = 0;
//   // commandPub.publish(theMsg); 
//            currentPose = getRobotPose(); 
//            angleToGoal = calculateAngle(currentPose.pose, goal.pose); 
//        
    
    
     /*  float angle = atan2(goal.pose.position.y - currentPose.pose.position.y, goal.pose.position.x - currentPose.pose.position.x);
    float difference_angle = angle - robotAngle;
    if (difference_angle * 180 / M_PI > 180)
    {
        difference_angle = (-360 + (difference_angle * 180 / M_PI)) * M_PI / 180;
    }
    else if(difference_angle * 180 / M_PI < -180){
        difference_angle = (360 - (difference_angle * 180 / M_PI)) * M_PI / 180;*/
   // }
//    rotationProcessing(true,  90);
//    return true;
/*}
void SeekBehaviour::rotateRobot() {
    ROS_INFO_STREAM("Rotate state ");
//    geometry_msgs::Twist theMsg;
//   
//    theMsg.angular.z = 0;
//    theMsg.linear.x  = 0;
    
    if(rotate)
    {
           rotationProcessing(true, angleToGoal);
           rotate = false;
            
    }
    return ;
}
*/
#ifndef SR_NODE_WALL_FOLLOWING
#define SR_NODE_WALL_FOLLOWING

#include "ros/ros.h"
#include "sensor_msgs/LaserScan.h"
#include "geometry_msgs/Twist.h"
#include "geometry_msgs/PoseStamped.h" 
#include <math.h>
#define PI 3.141592		//!<Mathematical constant (default value: 3.141592).	

#define SUBSCRIBER_BUFFER_SIZE 1	//!<Size of buffer for subscriber.

#define PUBLISHER_BUFFER_SIZE 1000	//!<Size of buffer for publisher.

// #define PUBLISHER_TOPIC "/syros/base_cmd_vel"

#define PUBLISHER_TOPIC "/cmd_vel0"

// #define SUBSCRIBER_TOPIC "/syros/laser_laser"

#define SUBSCRIBER_TOPIC "/base_scan"

/*! \brief Demonstration task: "Wall Following"
 * 
 * This class controls robot. Robot finds nearest wall and goes along it.
 */
 
 class NodeWallFollowing
{
public:
	
	/*! \brief A constructor.
	 * 
	 * @param pub Publisher, which can send commands to robot.
	 * @param wallDist Desired distance from the wall.
	 * @param maxSp Maximum speed, that robot can go.
	 * @param dir 1 for wall on the right side of the robot (-1 for the left one).
	 * @param pr P constant for PSD regulator.
	 * @param su S constant for PSD regulator.
	 * @param di D constant for PSD regulator.
	 * @param an Angle coeficient for regulator.
	 */
	NodeWallFollowing(ros::Publisher pub, double wallDist, double maxSp, int dir, double pr, double su, double di, double an);
	
	/*! \brief A destructor.
	 */
	~NodeWallFollowing();

	/*! \brief This method publishes commands for robot.
	 *
	 * Commands are generated from data, which are stored in variables
	 * (#angleMin, #angleMax, #distMin, #distMax). If the robot is far from 
	 * nearest obstacle (distMin is bigger than desired distance plus 
	 * constant), it turns to the obstacle and goes there. If it is near 
	 * the desired distance, it turns and goes along the obstacle. 
	 * The whole time, when robot is going along the obstacle (wall), it 
	 * tries to keep desired distance and angle from the wall. The higher
	 * is the diference between desired and actual values, the lower is 
	 * speed.
	 */
	
	void publishMessage();

	/*! \brief This method reads data from sensor and processes them to variables.
	 * 
	 * This method finds maximum and minimum distance in data from sensor
	 * and stores these values (with appropriate angles) into variables: 
	 * #angleMin, #angleMax, #distMin, #distMax.
	 * 
	 * @param msg Message, which came from robot and contains data from
	 * laser scan.
	 */
	
	void messageCallback(const sensor_msgs::LaserScan::ConstPtr& msg);
        void on_Goal_Received(geometry_msgs::PoseStamped goalMsg);

//variables
	double wallDistance;//!<Desired distance from the wall.
	double r;			//!<Difference between desired distance from the wall and actual distance.
	double sumR;		//!<Sum of #r.
	double diffR;		//!<Estimated next r;
	double maxSpeed;	//!<Maximum speed of robot.
	double P;			//!<P constant for PSD regulator.
	double S;			//!<S constant for PSD regulator.
	double D; 			//!<D constant for PSD regulator.
	double angleCoef;	//!<Angle coeficient for regulator.
	int direction;		//!<1 for wall on the right side of the robot (-1 for the left one).
	double angleMin;	//!<Angle, at which was measured the shortest distance.
	double distMin;		//!<Minimum distance masured by ranger.
	double distFront;	//!<Distance, measured by ranger in front of robot.
	int go;				//!<If the obstacle is in front of robot, change to 0.
	ros::Publisher pubMessage;	//!<Object for publishing messages.
        bool received ;
};

#endif



/*! \brief Starting node for task: "Wall Following"
 * 
 * In main function is created Subscribing node, which transmits messages 
 * to NodeWallFollowing object. There are the messages processed and commands 
 * generated.
 */

//Constructor and destructor
NodeWallFollowing::NodeWallFollowing(ros::Publisher pub, double wallDist, double maxSp, int dir, double pr, double su, double di, double an)
{
	wallDistance = wallDist;
	maxSpeed = maxSp;
	direction = dir;
	P = pr;
	S = su;
	D = di;
	angleCoef = an;
	r = 0;
	sumR = 0;
	distMin = 0;	//minimum distance masured by sensor
	angleMin = 0;	//angle, at which was measured the shortest distance
	go = 1;			//in case of obstacle, change to 0
	pubMessage = pub;
        received = false;
}
void NodeWallFollowing::on_Goal_Received(geometry_msgs::PoseStamped goalMsg) {
    //rotationProcessing(true, 90);
    
   received =true;
   /*goalX =goalMsg.pose.position.x;
   goalY =goalMsg.pose.position.y;
   

   double X =goalMsg.pose.position.x- currentX;
   double Y =goalMsg.pose.position.y- currentY;
   goalOrientation =  tf::getYaw(goalMsg.pose.orientation);
   CalculateDistanceError(X, Y);
   CalculateAngleErrorInRadians(Y,X);

   DriveToGoal ();*/
    
}

NodeWallFollowing::~NodeWallFollowing()
{
}

//Publisher
void NodeWallFollowing::publishMessage()
{
	//preparing message
	geometry_msgs::Twist msg;
	
	msg.angular.z = direction*(P*r + S*sumR + D*diffR) + angleCoef * (angleMin - PI*direction/2);		//PI regulator
	
	if (distFront < wallDistance){
		msg.linear.x = 0;
	}
	else if (distFront < wallDistance * 2){
		msg.linear.x = 0.5*maxSpeed;
	}
	else if (fabs(angleMin)>3){
		msg.linear.x = 0.4*maxSpeed;
	}
	else {
		msg.linear.x = maxSpeed;
	}
	
	//sending information about message to console
	ROS_INFO("Sending msg: linear.x=%f, angular.z=%f",msg.linear.x,msg.angular.z);
	
	//publishing message
       
         //   pubMessage.publish(msg);
        
}

//Subscriber
void NodeWallFollowing::messageCallback(const sensor_msgs::LaserScan::ConstPtr& msg)
{
	//Calculation of array size from angle range and angle increment.
	//int size = (int) ((msg->angle_max - msg->angle_min)/msg->angle_increment);
	int size = msg->ranges.size();
	//ROS_INFO("array_length: [%d]", size); 
	
	//Variables whith index of highest and lowest value in array.
	int minIndex = size*(direction+1)/4;
	
	//This cycle goes through array and finds minimum
	for(int i=(size*(direction+1)/2); i<(size*(direction+3)/2); i++)
	{
		if (msg->ranges[i] < msg->ranges[minIndex] && msg->ranges[i] > 0.0){
			minIndex = i;
		}
	}
	
	//Calculation of angles from indexes and storing data to class variables.
	angleMin = (minIndex-size/2)*msg->angle_increment;
	distMin = msg->ranges[minIndex];
	distFront = msg->ranges[size/2];
	diffR = 2*(distMin - wallDistance) - r;
	r = distMin - wallDistance;
	sumR += r;
	
	//Sending info about processed data
	ROS_INFO("min: angle=%f, distance=%f, front=%f", angleMin, distMin, distFront);
	
	//Invoking method for publishing message
         
            publishMessage();
         
}



int main(int argc, char **argv)
{
	//Initialization of node
	ros::init(argc, argv, "pointshoot_node");
	ros::NodeHandle n;
	
	//Creating publisher
	ros::Publisher pubMessage = n.advertise<geometry_msgs::Twist>(PUBLISHER_TOPIC, PUBLISHER_BUFFER_SIZE);
	
	//Creating object, which stores data from sensors and has methods for
	//publishing and subscribing
	NodeWallFollowing *nodeWallFollowing = new NodeWallFollowing(pubMessage, 0.13, 0.1, 1, 10, 0, 5, 1);
	
	//Creating subscriber and publisher
	ros::Subscriber sub = n.subscribe(SUBSCRIBER_TOPIC, SUBSCRIBER_BUFFER_SIZE, &NodeWallFollowing::messageCallback, nodeWallFollowing);
	ros::spin();

	return 0;
}
